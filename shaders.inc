// Autogenerated code
// to change, edit the corresponding file and rerun genshadersinc.py

// vertex.glsl
static const char vertex_glsl[] =
	"#version 150\n"
	"\n"
	"uniform int width;\n"
	"uniform int height;\n"
	"uniform int millis;\n"
	"in vec2 p;\n"
	"\n"
	"// pixel center\n"
	"centroid out vec2 pixelcenter;\n"
	"\n"
	"centroid out vec2 screenpixel;\n"
	"\n"
	"// pixel size... well, half of it\n"
	"//flat out vec2 pixel;\n"
	"\n"
	"void main() {\n"
	"    //pixel = vec2(1.0 / w, 1.0 / h);\n"
	"    vec2 whfactor = vec2(max(float(height) / float(width), 1.0), max(float(width) / float(height), 1.0));\n"
	"    vec2 p1 = p * whfactor;\n"
	"    vec4 pos = vec4(p1, 0.5, 1.0);\n"
	"    pixelcenter = p;\n"
	"    screenpixel = p1;\n"
	"    gl_Position = pos;\n"
	"}\n"
	"\n";
static const size_t vertex_glslsz = sizeof(vertex_glsl) - 1;

// fragment_pre.glsl
static const char fragment_pre_glsl[] =
	"#version 150\n"
	"\n"
	"const float TAU = 6.2831853;\n"
	"\n"
	"uniform int millis;\n"
	"uniform int currentFramebuffer;\n"
	"uniform mat4 camera;\n"
	"\n"
	"#define MOTIONBLUR_COEFFICIENT 4.0\n"
	"// newlines left as space to insert motionblur factor\n"
	"// keep them at least 3!\n"
	"#define MOTIONBLUR_FACTOR \n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"uniform sampler2D framessampler[MOTIONBLUR_FACTOR];\n"
	"\n"
	"// ray\n"
	"centroid in vec2 pixelcenter;\n"
	"centroid in vec2 screenpixel;\n"
	"\n"
	"/*\n"
	"// pixel size\n"
	"flat in vec2 pixel;\n"
	"*/\n"
	"\n"
	"out vec4 colorBackLeft;\n"
	"out vec4 colorObject;\n"
	"\n"
	"/*\n"
	"// set this to something depending on\n"
	"// both time and pixel\n"
	"uint rand_state = 0u;\n"
	"\n"
	"float rand() {\n"
	"    rand_state = ((rand_state * 1664525u + 1013904223u) >> 8) & 0xFFFFFFu;\n"
	"    return float(rand_state) / float(0xFFFFFF);\n"
	"}\n"
	"\n"
	"vec2 rand2_state = vec2(-0.75, 0.75);\n"
	"vec2 rand2_state_m = vec2(-1.0, 1.0);\n"
	"\n"
	"void srand2(int seed) {\n"
	"}\n"
	"\n"
	"vec2 rand2() {\n"
	"    rand2_state *= rand2_state_m;\n"
	"    rand2_state_m *= vec2(-1.0, -1.0);\n"
	"    return rand2_state;\n"
	"}\n"
	"*/\n"
	"float mixfix(float a, float b, float t) {\n"
	"    // this piece is nonsensical but without it\n"
	"    // we get a black screen, fuck you nVidia\n"
	"    // fuck you with a rusty rake\n"
	"    // (pls fix your floating point)\n"
	"    float u;\n"
	"    t = clamp(t, 0.0, 1.0);\n"
	"    u = 1.0 - t;\n"
	"    u = clamp(u, 0.0, 1.0);\n"
	"    return a * u + b * t;\n"
	"}\n"
	"\n"
	"/*rotation matrix that will make d point the same direction as z*/\n"
	"/*both must be normalized*/\n"
	"/*\n"
	"mat3x3 rotationAlign(vec3 d, vec3 z) {\n"
	"    vec3 v = cross(z, d);\n"
	"    float c = dot(z, d);\n"
	"    float k = 1.0f / (1.0f + c);\n"
	"    return k * outerProduct(v, v) +\n"
	"        mat3x3(c, v.z, -v.y,\n"
	"               -v.z, c, v.x,\n"
	"               v.y, -v.x, c);\n"
	"}\n"
	"*/\n"
	"\n"
	"float plane(vec3 p, vec3 c, vec3 n) {\n"
	"    return dot(n, p) - dot(n, c);\n"
	"}\n"
	"\n"
	"/*cube with 3 lengths*/\n"
	"float cube(vec3 p, vec3 c, vec3 vr) {\n"
	"    vec3 bmin = c - vr;\n"
	"    vec3 bmax = c + vr;\n"
	"    vec3 dmin = bmin - p;\n"
	"    vec3 dmax = p - bmax;\n"
	"    vec3 max1 = max(dmin, dmax);\n"
	"    vec2 max2 = max(max1.xy, max1.z);\n"
	"    return max(max2.x, max2.y);\n"
	"}\n"
	"\n"
	"/*proper cube*/\n"
	"float cube(vec3 p, vec3 c, float r) {\n"
	"    vec3 vr = vec3(r, r, r);\n"
	"    return cube(p, c, vr);\n"
	"}\n"
	"\n"
	"/*sphere*/\n"
	"float sphere(vec3 p, vec3 c, float r) {\n"
	"    return distance(c, p) - r;\n"
	"}\n"
	"\n"
	"/*torus*/\n"
	"/*rc - radius to centre of tube*/\n"
	"/*rt - radius of tube*/\n"
	"float torus(vec3 p, vec3 c, vec3 n, float rc, float rt) {\n"
	"    // equation is\n"
	"    // (rmax - sqrt(dot(p.xy))) ** 2 + z**2 - rmin**2\n"
	"    // for torus symmetric around z\n"
	"    float z = dot(p, n) - dot(c, n);\n"
	"    vec3 p1 = p - z * n;\n"
	"    float xy2 = dot(p1 - c, p1 - c);\n"
	"    float b = rc - sqrt(xy2);\n"
	"    return sqrt(b * b + z * z) - rt;\n"
	"}\n"
	"\n"
	"/*\n"
	"float cylinderx(vec3 p, vec3 c, float h, float r) {\n"
	"    vec3 q = p - c;\n"
	"    return max(max(-h - q.x, q.x - h), sqrt(dot(q.yz, q.yz)) - r);\n"
	"}\n"
	"\n"
	"float cylindery(vec3 p, vec3 c, float h, float r) {\n"
	"    vec3 q = p - c;\n"
	"    return max(max(-h - q.y, q.y - h), sqrt(dot(q.xz, q.xz)) - r);\n"
	"}\n"
	"*/\n"
	"\n"
	"/*cylinder with spherical caps at ends*/\n"
	"/* a, b - centres of the caps, r - radius */\n"
	"float cylinder_caps(vec3 p, vec3 a, vec3 b, float r) {\n"
	"    vec3 n = normalize(b - a);\n"
	"    vec3 p1 = p - a;\n"
	"    float d = dot(n, p1);\n"
	"    vec3 c = d * n;\n"
	"    if (dot(n, c) < 0.0f) {\n"
	"        return sphere(p, a, r);\n"
	"    }\n"
	"    if (dot(n, c) > distance(a, b)) {\n"
	"        return sphere(p, b, r);\n"
	"    }\n"
	"    float daxis = length(p1 - d * n);\n"
	"    return daxis - r;\n"
	"}\n"
	"\n"
	"/* tile vec3 around the centre with radius r */\n"
	"vec3 tile(vec3 p, vec3 r) {\n"
	"    return 2 * (fract((p + r) / (2 * r)) - vec3(0.5, 0.5, 0.5)) * r;\n"
	"}\n"
	"\n"
	"// 0.0 - 1.0\n"
	"float timing(int p) {\n"
	"    return float(int(millis) % p) / float(p - 1);\n"
	"}\n"
	"\n"
	"// 0.0 - 1.0 - 0.0\n"
	"float timing2(int p) {\n"
	"    float t = timing(p);\n"
	"    return 2.0 * (0.5 - abs(t - 0.5));\n"
	"}\n"
	"\n";
static const size_t fragment_pre_glslsz = sizeof(fragment_pre_glsl) - 1;

// fragment_post.glsl
static const char fragment_post_glsl[] =
	"\n"
	"/* gradient */\n"
	"vec3 grad(vec3 p) {\n"
	"    float eps = 0.0001;\n"
	"    return normalize(vec3(\n"
	"                dist_object(p - vec3(eps, 0.0, 0.0)) - dist_object(p + vec3(eps, 0.0, 0.0)),\n"
	"                dist_object(p - vec3(0.0, eps, 0.0)) - dist_object(p + vec3(0.0, eps, 0.0)),\n"
	"                dist_object(p - vec3(0.0, 0.0, eps)) - dist_object(p + vec3(0.0, 0.0, eps))));\n"
	"}\n"
	"\n"
	"/* trace from point p along ray r */\n"
	"vec4 trace(vec3 p, vec3 r) {\n"
	"    vec3 p1 = p;\n"
	"    float d = dist_object(p);\n"
	"    float epsilon = 1.0e-05;\n"
	"    // Kalman summation\n"
	"    float dsum = 0.0;\n"
	"    float dsumerr = 0.0;\n"
	"    float tmp;\n"
	"    for (int i = 0; i < 512 && d >= epsilon; i++) {\n"
	"        // escape if too long\n"
	"        if (dsum > 16) {\n"
	"            return vec4(p1, 0.0);\n"
	"        }\n"
	"        tmp = dsum;\n"
	"        dsum = dsum + d;\n"
	"        tmp = tmp - (dsum - d);\n"
	"        dsumerr = dsumerr + tmp;\n"
	"        p1 = dsumerr * r + dsum * r + p;\n"
	"        d = dist_object(p1);\n"
	"    }\n"
	"    if (d > epsilon) {\n"
	"        return vec4(p1, 0.0);\n"
	"    } else {\n"
	"        // woop woop\n"
	"        for (int j = 0; j < 16 && d < 0; j++) {\n"
	"            tmp = dsum;\n"
	"            dsum = dsum + d;\n"
	"            tmp = tmp - (dsum - d);\n"
	"            dsumerr = dsumerr + tmp;\n"
	"            p1 = dsumerr * r + dsum * r + p;\n"
	"            d = dist_object(p1);\n"
	"        }\n"
	"        p1 = dsumerr * r + dsum * r + p;\n"
	"        return vec4(p1, 1.0);\n"
	"    }\n"
	"}\n"
	"\n"
	"vec3 srgb(float r, float g, float b) {\n"
	"    vec3 c = vec3(r / 255.0, g / 255.0, b / 255.0);\n"
	"    return pow(c, vec3(2.2, 2.2, 2.2));\n"
	"}\n"
	"\n"
	"vec3 texmex(vec3 p, vec3 n) {\n"
	"//    return (vec3(1.0, 1.0, 1.0) + n) * 0.5;\n"
	"//    return vec3(1.0, 1.0, 1.0);\n"
	"    \n"
	"    // glTexGen GL_SPHERE_MAP\n"
	"    vec3 u = normalize(p);\n"
	"    vec3 f = u - 2 * dot(n, u) * n;\n"
	"    float m = 2 * sqrt(f.x * f.x + f.y * f.y + (f.z + 1) * (f.z + 1));\n"
	"    vec2 t = f.xy / m + vec2(0.5, 0.5);\n"
	"\n"
	"    // :/\n"
	"//    float sblue = sin(dot(t, t) * 18 * TAU);\n"
	"//    sblue = (sblue + 1) * 0.5;\n"
	"    //float sblue = step(0.5, fract((t.x * t.x + t.y * t.y) * 1.5));\n"
	"    //float sblue = step(0.5, fract((t.x + t.y) * 1.5));\n"
	"    //return mix(srgb(89, 132, 50), srgb(148, 174, 22), sblue);\n"
	"    //return mix(srgb(246, 200, 44), srgb(250, 236, 147), sblue);\n"
	"    //return vec3(t, 0.3 + 0.4 * timing2(12345));\n"
	"    float c = distance(vec2(0.5, 0.5), t) * 1.8;\n"
	"    return vec3(1.0, 1.0 - c, 1.0 - c);\n"
	"}\n"
	"\n"
	"const vec3 light1 = normalize(vec3(-0.0, -0.2, -0.0));\n"
	"const vec3 light2 = normalize(vec3(0.1, -0.1, -0.0));\n"
	"vec3 light3_pos = vec3(-0.2, 0, 2.5);\n"
	"vec3 shade(vec3 p) {\n"
	"    vec3 n = grad(p);\n"
	"    vec3 light3 = normalize(p - light3_pos);\n"
	"    vec4 m1 = trace(p - light1 * 0.05, -light1);\n"
	"    vec4 m2 = trace(p - light2 * 0.05, -light2);\n"
	"    vec4 m3 = trace(light3_pos, light3);\n"
	"    float factor1 = (1.0 - m1.w) * dot(n, light1);\n"
	"    float factor2 = (1.0 - m2.w) * dot(n, light2);\n"
	"    m3.xyz -= p;\n"
	"    float factor3 = (1.0 - step(0.01, dot(m3.xyz, m3.xyz)) * m3.w) * dot(n, light3);\n"
	"\n"
	"    vec3 c = texmex(p, n);\n"
	"\n"
	"/*\n"
	"    vec3 light1c = vec3(1, 1, 1);\n"
	"    vec3 light2c = vec3(1, 1, 1);\n"
	"    vec3 light3c = vec3(1, 1, 1);\n"
	"*/\n"
	"    vec3 light1c = vec3(0.9, 0.1, 0.1);\n"
	"    vec3 light2c = vec3(0.1, 0.9, 0.1);\n"
	"    vec3 light3c = vec3(0.1, 0.1, 0.9);\n"
	"    // no light shadows only\n"
	"//   return c * ((2.0 - m1.w - m2.w) * 2.0 / 3.0 + 1.0 / 3.0);\n"
	"    // three lights\n"
	"     return min((\n"
	"     max(factor1, 0.0) * light1c +\n"
	"     max(factor2, 0.0) * light2c +\n"
	"     max(factor3, 0.0) * light3c\n"
	"     ) / (light1c + light2c + light3c) * c, c);\n"
	"    // debug shadows\n"
	"//    return vec3(m1.w, m2.w, 0.0);\n"
	"}\n"
	"\n"
	"vec4 go(vec3 p, vec3 ray) {\n"
	"    // wavy effect1\n"
	"    \n"
	"    /*\n"
	"    float phi = TAU * 2 * (ray.x + ray.y);\n"
	"    p.z += sin(phi) * cos(phi) * 0.01;\n"
	"    */\n"
	"\n"
	"    // wavy effect2\n"
	"    /*\n"
	"    float phi = TAU * timing2(15000);\n"
	"    ray.x *= sin(phi + ray.x);\n"
	"    */\n"
	"\n"
	"    vec4 q = trace(p, ray);\n"
	"    vec3 result;\n"
	"    if (q.w < 1.0) {\n"
	"        return vec4(0.0, 0.0, 0.0, 0.0);\n"
	"    }\n"
	"    p = q.xyz;\n"
	"    return vec4(shade(p), 1.0);\n"
	"}\n"
	"\n"
	"void main() {\n"
	"    //rand_state = uint(millis) + uint((pixelcenter.x + pixelcenter.y) * 1000);\n"
	"    vec3 p = vec3(0.0, 0.0, 1.3);\n"
	"    vec3 t = vec3(pixelcenter, 0.98);\n"
	"\n"
	"    light3_pos = (camera * vec4(light3_pos, 1.0)).xyz;\n"
	"    p = (camera * vec4(p, 1.0)).xyz;\n"
	"\n"
	"    vec3 tr;\n"
	"    vec3 ray = normalize((camera * vec4(t, 1.0)).xyz - p);\n"
	"    vec4 result = go(p, ray);\n"
	"/*\n"
	"    // the number of iterations plus one must be\n"
	"    // divided by below.\n"
	"    // anti-aliasing is turned off right now because it murders performance\n"
	"    for (i = 0; i < 0; i++) {\n"
	"        tr = t + vec3(pixel * rand2(), 0.0);\n"
	"        tr = (camera * vec4(tr, 1.0)).xyz;\n"
	"        ray = normalize(tr - p);\n"
	"        result += go(p, ray);\n"
	"    }\n"
	"*/\n"
	"    vec4 c = result;\n"
	"    vec2 texcoord = (vec2(1, 1) + screenpixel) * 0.5;\n"
	"    float factor = 1.0 / MOTIONBLUR_COEFFICIENT;\n"
	"    for (int i = 0, j = currentFramebuffer;\n"
	"            i < MOTIONBLUR_FACTOR - 1; i++) {\n"
	"        j = (j + MOTIONBLUR_FACTOR - 1) % MOTIONBLUR_FACTOR;\n"
	"        c += texture(framessampler[j], texcoord) * factor;\n"
	"        factor /= MOTIONBLUR_COEFFICIENT;\n"
	"    }\n"
	"    c *= (MOTIONBLUR_COEFFICIENT - 1) / (MOTIONBLUR_COEFFICIENT - pow(MOTIONBLUR_COEFFICIENT, -float(MOTIONBLUR_FACTOR)));\n"
	"    colorObject = result;\n"
	"    // gamma correction for standard monitor\n"
	"    float g = 1.0 / 2.2;\n"
	"    colorBackLeft = pow(c, vec4(g, g, g, 1.0));\n"
	"}\n"
	"\n";
static const size_t fragment_post_glslsz = sizeof(fragment_post_glsl) - 1;

// fragment_text.glsl
static const char fragment_text_glsl[] =
	"uniform sampler2D textsampler;\n"
	"\n"
	"#define TRANSITION 1\n"
	"\n"
	"void main() {\n"
	"    vec2 t = (pixelcenter + vec2(1.0, 1.0)) / 2;\n"
	"    float f = timing(6000);\n"
	"    float coming = smoothstep(0, 0.4, f);\n"
	"    float going = smoothstep(0.6, 1, f);\n"
	"    vec2 t1;\n"
	"    vec2 t2;\n"
	"#if TRANSITION == 0\n"
	"    t1 = pow(t, vec2(coming, coming));\n"
	"    t2 = vec2(1, 1) - pow((vec2(1, 1) - t), vec2(1 - going, 1 - going));\n"
	"#elif TRANSITION == 1\n"
	"    t1 = clamp(t, 1 - coming, 1);\n"
	"    t2 = clamp(t, 0, 1 - going);\n"
	"#elif TRANSITION == 2\n"
	"    t1 = clamp(t, 0, pow(coming, 0.5));\n"
	"    t2 = clamp(t, pow(going, 0.5), 1);\n"
	"#elif TRANSITION == 3\n"
	"    t1 = coming * t;\n"
	"    t2 = (1 - going) * t;\n"
	"#elif TRANSITION == 4\n"
	"    t1 = pow(t, vec2(coming, coming));\n"
	"    t2 = vec2(1, 1) - pow((vec2(1, 1) - t), vec2(1 - going, 1 - going));\n"
	"    t1 = clamp(t1, pow(1 - coming, 2), 1);\n"
	"    t2 = clamp(t2, 0, pow(1 - going, 2));\n"
	"#endif\n"
	"    float d;\n"
	"    if (f < 0.5) {\n"
	"        d = texture(textsampler, t1);\n"
	"    } else {\n"
	"        d = texture(textsampler, t2);\n"
	"    }\n"
	"    vec4 result = vec4(d, d, d, 1 - smoothstep(0.8, 1, f));\n"
	"\n"
	"    vec4 c = result;\n"
	"    vec2 texcoord = (vec2(1, 1) + screenpixel) * 0.5;\n"
	"    for (int i = 0; i < MOTIONBLUR_FACTOR; i++) {\n"
	"        c += texture(framessampler[i], texcoord);\n"
	"    }\n"
	"    c /= MOTIONBLUR_FACTOR;\n"
	"    colorObject = result;\n"
	"    // gamma correction for standard monitor\n"
	"    float g = 1.0 / 2.2;\n"
	"    colorBackLeft = pow(c, vec4(g, g, g, 1.0));\n"
	"}\n"
	"\n"
	"\n";
static const size_t fragment_text_glslsz = sizeof(fragment_text_glsl) - 1;

